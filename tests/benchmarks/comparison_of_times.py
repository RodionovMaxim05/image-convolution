import os
import numpy as np
import matplotlib.pyplot as plt
import re
import filecmp
import sys
from utils import analyze_execution_data, print_warning, get_image_resolution

# Configuration constants
PROGRAM_PATH = "./build/src/image-convolution"
IMAGE_NAME = sys.argv[1]
IMAGE_PATH = "images/" + IMAGE_NAME
IMAGE_RESOLUTION = get_image_resolution(IMAGE_PATH)
OUTPUT_DIR = f"tests/plots/{IMAGE_RESOLUTION[0]}x{IMAGE_RESOLUTION[1]}"
NUM_RUNS = 40
THREAD_NUM = 4

PARALLEL_MODES = ["pixel", "row", "column", "block"]
ALL_MODES = ["seq"] + PARALLEL_MODES

FILTERS = ["id", "bl", "gbl", "mbl", "ed", "em"]
FILTERS_INFO = [
    "Identity Filter (3x3 kernel)",
    "Standard Blur Filter (5x5 kernel)",
    "Gaussian Blur Filter (5x5 kernel)",
    "Motion Blur Filter (9x9 kernel)",
    "Edge Detection Filter (3x3 kernel)",
    "Emboss Filter (5x5 kernel)",
]
FILTERS_DICT = dict(zip(FILTERS, FILTERS_INFO))

os.makedirs(OUTPUT_DIR, exist_ok=True)


def run_program(filter: str, mode: str):
    """
    Runs the convolution program for a specific filter and execution mode, capturing execution times over multiple runs.

    Args:
        filter (str): Name of the filter to apply.
        mode (str): Execution mode.

    Returns:
        A NumPy array containing execution times for all runs.
    """
    execution_times = []
    if mode == "seq":
        command = f"{PROGRAM_PATH} {IMAGE_PATH} {filter} --mode={mode}"
    else:
        command = f"{PROGRAM_PATH} {IMAGE_PATH} {filter} --mode={mode} --thread={THREAD_NUM}"

    for _ in range(NUM_RUNS):
        output = os.popen(command).read().strip()
        match = re.search(r"The convolution took (\d+\.\d+)", output)
        if match:
            time = float(match.group(1))
            execution_times.append(time)
        else:
            print_warning(f"Failed to parse output: {output}")

    return np.array(execution_times)


def round_results(mean_time, confidence_interval):
    """
    Rounds the mean execution time and confidence interval to a consistent number of significant figures.

    Args:
        mean_time (float): Mean execution time.
        confidence_interval (float): Confidence interval for the mean.

    Returns:
        A tuple (rounded_mean, rounded_conf_inter) with appropriately rounded values.
    """
    rounded_conf_inter = round(
        confidence_interval, -int(np.floor(np.log10(abs(confidence_interval))))
    )
    rounded_mean = round(
        mean_time, -int(np.floor(np.log10(abs(rounded_conf_inter))))
    )

    return rounded_mean, rounded_conf_inter


def compare_output_images(filter: str, mode: str) -> bool:
    """
    Compares the output image generated by a specific filter and mode with the reference image produced by the sequential mode.

    Args:
        filter (str): Name of the filter.
        mode (str): Execution mode.

    Returns:
        `True` if the images are identical, `False` otherwise.
    """
    output_file = f"images/{filter}_{mode}_{IMAGE_NAME}"
    ref_file = f"images/{filter}_seq_{IMAGE_NAME}"

    return filecmp.cmp(output_file, ref_file, shallow=False)


def main() -> None:
    """The main function organizes the comparative analysis process,
    including performing tests, analyzing results, saving results and creating graphs.
    """
    data_file = open(f"{OUTPUT_DIR}/benchmark_results.txt", "w+")

    results = {filter: {"means": [], "conf_inter": []} for filter in FILTERS}

    # Run benchmarks for all filters and modes
    for filter in FILTERS:
        data_file.write(f"FILTER: {FILTERS_DICT[filter]}\n\n")

        for mode in ALL_MODES:
            print(f"Running measurements: {filter} filter - {mode} mode")
            times = run_program(filter, mode)

            mean_time, confidence_interval = analyze_execution_data(times)
            results[filter]["means"].append(mean_time)
            results[filter]["conf_inter"].append(confidence_interval)

            rounded_mean, rounded_error = round_results(
                mean_time, confidence_interval
            )

            # Save benchmark results to a text file
            data_file.write(f"\tMode: {mode}\n")
            data_file.write(f"\t\tResult: {rounded_mean} Â± {rounded_error} s\n")

            # Compare with the reference file (sequential output)
            if mode != "seq":
                if compare_output_images(filter, mode):
                    data_file.write(
                        f"\t\tThe image is identical to the sequential output\n"
                    )
                else:
                    data_file.write(
                        f"WARNING: The image is NOT identical to the sequential output\n"
                    )
                    print_warning(
                        f"Output mismatch for filter {filter} in mode {mode}"
                    )

        data_file.write("\n\n")

        # Create a plot of the results of individual filters.

        # mode 'seq' is not taken into account
        x_pos = np.arange(len(PARALLEL_MODES))
        filtered_means = [
            results[filter]["means"][i]
            for i, mode in enumerate(ALL_MODES)
            if mode != "seq"
        ]
        filtered_errors = [
            results[filter]["conf_inter"][i]
            for i, mode in enumerate(ALL_MODES)
            if mode != "seq"
        ]

        plt.bar(
            x=x_pos,
            height=filtered_means,
            yerr=filtered_errors,
            align="center",
            alpha=0.7,
            capsize=10,
            color=(["#efa94a", "#47a76a", "#db5856", "#9966cc"]),
        )
        plt.xticks(x_pos, PARALLEL_MODES)
        plt.ylabel("Execution Time (s)")
        plt.title(f"Execution Times for {FILTERS_DICT[filter]}")

        individual_chart_path = os.path.join(OUTPUT_DIR, f"histogram_{filter}.png")
        plt.tight_layout()
        plt.savefig(individual_chart_path)
        plt.clf()

    data_file.close()

    # Create a plot of of comparison chart.

    bar_width = 0.15
    x_pos = np.arange(len(FILTERS))
    _, ax = plt.subplots(figsize=(12, 6))

    # Plot bars for each mode
    for i, mode in enumerate(ALL_MODES):
        ax.bar(
            x=(x_pos + i * bar_width),
            height=[results[filter]["means"][i] for filter in FILTERS],
            yerr=[results[filter]["conf_inter"][i] for filter in FILTERS],
            width=bar_width,
            label=mode,
            align="center",
            alpha=0.7,
            capsize=5,
        )

    ax.set_xticks(x_pos + bar_width * (len(ALL_MODES) - 1) / 2)
    ax.set_xticklabels(
        [FILTERS_DICT[filter] for filter in FILTERS], rotation=45, ha="right"
    )
    ax.set_ylabel("Execution Time (s)")
    ax.set_title("Performance Comparison of Different Filters and Modes")
    ax.legend(title="Modes", loc="upper left", bbox_to_anchor=(1, 1))

    grouped_chart_path = os.path.join(OUTPUT_DIR, "grouped_bar_chart.png")
    plt.tight_layout()
    plt.savefig(grouped_chart_path)

    print(f"Measurements and charts saved to '{OUTPUT_DIR}' directory.")


if __name__ == "__main__":
    main()
